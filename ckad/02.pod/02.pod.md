### POD

 k8s does not deploy containers directly in worker nodes. k8s encapsulates containers in a k8s object called pods. A pod is a single instance of an application. A pod is the smallest object you can create in k8s

 pod - container - 1:1 relationship

 A single pod can have multiple container when they are not of the same kind. Like application container + helper container, both can use same storage space.
 If our intention was to scale our application, we would have to create additional pod.
 Multipod container is a rare use case

### how do deploy pods?

what does `k8s run` command do?
ex: `k8s run ngnix --image ngnix`
It creates a pod and deploys an instance of the ngnix docker image.
Where does it get the application image from? We need to specify image name in the `image` parameter.
The application image name, in this case `ngnix` image is downloaded from docker hub repository.
Docker hub is the public repository where various docker images are stored.
You can configure k8s to pull the image from public docker hub or private company's docker hub.

k8s uses yaml files as inputs for the creation of objects like pods, deployments, replicas, services etc... 

### Resource requests

A pod requires 0.5 CPU and 256 MiByte of memory

Mebibyte:
A mebibyte is equal to 220 or 1,048,576 byte

### Readiness
When the pod is ready to accept traffic

k8s assumes the pod is ready as soon as the container is creater, but we might take more time to setup db connection etc...  that is why we give separate end point in readiness_probe

Failing liveness probe will restart the container, whereas failing readiness probe will stop our application from serving traffic.

`liveness` and `readiness` have exactly similar attributes

### Affinity and Anti Affinity

using affinity rules, you could spread or pack pods within a service or relative to pods in other services. Anti-affinity rules allow you to prevent pods of a particular service from scheduling on the same nodes as pods of another service that are known to interfere with the performance of the pods of the first service.

### Labels

```sh
kubectl get pods --show-labels

kubectl label pod/helloworld app=helloword-app —overwrite

kubectl label pod/helloworld author- #to remove labels

kubectl get pods --selector env=production #search based on label’s key and value

kubectl get pods --selector dev-lead=carisa,env=staging #search by multiple label

kubectl get pods --selector dev-lead!=carisa,env=staging #search by !=

kubectl get pods -l 'release-version in (1.0,2.0)' # search labels with multiple values

kubectl get po -l app=v2

k get pods -l env=prod

kubectl get pods -l 'release-version not in (1.0,2.0)'

k get pods --no-headers | wc -l

kubectl label po -l "app in(v1,v2)" tier=web

kubectl annotate po -l "app=v2" owner=marketing
```

### Remove label from 3 pods
```sh
kubectl label po nginx1 nginx2 nginx3 app-
# or
kubectl label po nginx{1..3} app-
# or
kubectl label po -l app app-
```

### Annotate 3 pods
```sh
kubectl annotate po nginx1 nginx2 nginx3 description='my description'

#or

kubectl annotate po nginx{1..3} description='my description'
```

If the label value is not known

```sh
kubectl get po -L app
# or
kubectl get po --label-columns=app
```

